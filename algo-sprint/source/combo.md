# 组合与刷题技巧 — 按日分节

> 每日读完 algorithm.md 当日小节后，再读本文件同日小节。读完后做 **practice.md** 当日例题，再做 **quiz.md** 当日自测。

---

## 模式信号速查表（贯穿 7 天，做题前扫一眼）

> 遇到一道题，先扫左列找到匹配的信号，右列就是你的第一直觉。详细决策树见 [thinking.md](thinking.md)。

| 题面信号 | → 数据结构 | → 算法模式 | 典型题 |
|----------|-----------|-----------|--------|
| 有序数组 + 目标值 | 数组 | 二分 / 相向双指针 | LC167, LC33 |
| 连续子数组/子串 + 最长/最短 | 数组 + map/计数 | 滑动窗口 | LC3, LC76, LC209 |
| 所有排列/组合/子集 | 数组 | 回溯 | LC46, LC78, LC39 |
| 下一个更大/更小 | 栈 | 单调栈 | LC496, LC739 |
| 合并 K 个有序 / TopK | 堆 | 多路归并 / 堆维护 | LC23, LC215 |
| 树的深度/路径/属性 | 树 | DFS 递归（前/中/后序） | LC104, LC112, LC236 |
| 按层输出 / 最短步数 | 队列 | BFS | LC102, LC127 |
| 是否能 / 方案数 / 最值 + 子序列 | 数组 | DP | LC70, LC300, LC322 |
| 连通/分组/朋友圈 | 并查集 或 图 | Union-Find / DFS | LC547, LC200 |
| 依赖/先修/执行顺序 | 图 | 拓扑排序 | LC207, LC210 |
| 括号/嵌套/匹配 | 栈 | 栈匹配 | LC20, LC32 |
| 原地/O(1) 空间 | 数组 | 双指针 / 位运算 | LC26, LC283 |

---

## 通用刷题技巧（贯穿 7 天）

1. **UMPIRE 先行**：每道题都走一遍 Understand → Match → Plan → Implement → Review → Evaluate（详见 [thinking.md](thinking.md)）。
2. **先想再写**：口头说清「用什么结构、什么循环、边界」，再写代码，减少返工。
3. **写完必检查**：过一遍 [边界清单](thinking.md)（空、单元素、全同、溢出、奇偶）。
4. **Golang 注意**：slice 传参是引用、map 取不到 key 返回零值、递归尽量用返回值而非全局变量、收集 path 时深拷贝。
5. **时间**：自测题限时（20～30 分钟/题），模拟笔试节奏。

---

## Day 1：数组 + 双指针与滑窗

### 如何选择双指针的模式

```
  题目要求            →  选哪种双指针
  ─────────────────────────────────────
  有序数组两数之和     →  相向双指针
  判断回文串           →  相向双指针
  原地去重/移动元素    →  同向双指针（快慢/读写）
  连续子串/子数组优化  →  滑动窗口（同向的变体）
  链表中点/判环        →  快慢指针（Day 2）
```

### 滑动窗口的思考步骤

1. **窗口里维护什么？** 通常是 map 计数、或一个 sum 变量
2. **什么时候扩张右边界？** 一般是无条件扩（for 循环的 r++）
3. **什么时候收缩左边界？** 当窗口「不合法」时（while 循环）
4. **在哪里更新答案？** 通常在收缩完毕后（窗口合法时）

### 常见变体总结

| 问题 | 窗口状态 | 何时收缩 | 更新答案 |
|------|----------|----------|----------|
| 最长无重复子串 | map 记字符出现次数 | `count[c] > 1` | 收缩后 `r-l+1` |
| 最小覆盖子串 | map 记 t 中字符满足数 | 满足覆盖时收缩 | 收缩时更新最小长度 |
| 长度最小的子数组 | sum | `sum >= target` | 收缩时更新最小长度 |
| 固定长度最大和 | sum | 窗口超过 k | 每步更新 max |

### 边界提醒

- **空数组**：函数入口判 `len(nums) == 0`
- **全相同元素**：去重后只剩 1 个
- **整个数组满足条件**：如 `target=1, nums=[2,3,4]`，滑窗第一个元素就满足

**下一站**：→ [practice.md - Day 1](practice.md#day-1) → [quiz.md - Day 1](quiz.md#day-1)

---

## Day 2：链表 + 快慢指针与 dummy

### dummy 节点判断法

**用不用 dummy？** 问自己一个问题：**头节点可能变吗？**
- 删除操作可能删掉 head → **用**
- 合并两链表，新头不确定 → **用**
- 反转链表，head 变成尾 → 可用可不用（三指针法不需要）
- 只是遍历/查找 → 不用

### 链表题的常见组合

| 问题 | 技巧组合 |
|------|----------|
| 反转整个链表 | 三指针迭代 或 递归 |
| 反转前 k 个 / 区间反转 | 定位到区间 + 反转 + 接回 |
| 删除倒数第 k 个 | 快指针先走 k 步 + dummy |
| 合并两个有序 | dummy + 比较 |
| 合并 K 个有序 | 堆 + dummy（Day 3 堆） |
| 判环 / 找环入口 | 快慢指针 |
| 找中点 | 快慢指针 |
| 排序链表 | 找中点 + 归并排序 |
| 回文链表 | 找中点 + 反转后半 + 比较 |

### 链表调试技巧

- **画图**：每一步都画出节点和箭头，标清 prev/cur/next 指向
- **特别注意**：`cur.Next = prev` 之后原来的 `cur.Next` 就丢了，所以要提前 `next = cur.Next`
- **测试**：nil 链表、单节点、两节点、奇/偶长度

**下一站**：→ [practice.md - Day 2](practice.md#day-2) → [quiz.md - Day 2](quiz.md#day-2)

---

## Day 3：栈 + 队列 + 堆的选用

### 什么时候用什么

```
  需要「最近的」匹配 / 嵌套结构    →  栈
  需要「单调性」/ 下一个更大更小   →  单调栈
  需要「按层扩展」/ 最短步数       →  队列 (BFS)
  需要「动态取最值」/ TopK         →  堆
  需要「窗口内最值」               →  单调双端队列
```

### 单调栈要点

- **栈内存下标**（不是值），因为经常需要下标计算距离
- **严格单调**还是**非严格单调**？看题是「更大」还是「大于等于」
- **正向还是反向遍历**？取决于求「右边的」还是「左边的」

### 堆的使用模板（Go）

```go
import "container/heap"

// 定义类型
type Item struct {
    val, idx int
}
type PQ []*Item
func (h PQ) Len() int            { return len(h) }
func (h PQ) Less(i, j int) bool  { return h[i].val < h[j].val } // 小顶
func (h PQ) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *PQ) Push(x interface{}) { *h = append(*h, x.(*Item)) }
func (h *PQ) Pop() interface{}   { old := *h; x := old[len(old)-1]; *h = old[:len(old)-1]; return x }

// 使用
h := &PQ{}
heap.Push(h, &Item{val: 5, idx: 0})
top := heap.Pop(h).(*Item)
```

### BFS 的两种写法

**写法一：不分层**（只关心能否到达、最短距离）

```go
q := []int{start}; visited[start] = true
for len(q) > 0 {
    u := q[0]; q = q[1:]
    for _, v := range g[u] { ... }
}
```

**写法二：分层**（需要知道当前是第几层/步）

```go
q := []int{start}; visited[start] = true; step := 0
for len(q) > 0 {
    size := len(q)
    for i := 0; i < size; i++ {
        u := q[0]; q = q[1:]
        // 处理第 step 层的节点
        for _, v := range g[u] { ... }
    }
    step++
}
```

**下一站**：→ [practice.md - Day 3](practice.md#day-3) → [quiz.md - Day 3](quiz.md#day-3)

---

## Day 4：树题模板

### 解树题的三问

拿到一道树的题，先问自己：

1. **用什么序？** 需要先处理根 → 前序；需要左右结果才能算根 → 后序；BST 有序 → 中序
2. **递归函数返回什么？** 高度、bool、节点指针、最大值……
3. **需要传什么额外信息？** min/max 区间、当前路径、父节点……

### 常见树题模式

| 问题 | 遍历序 | 返回值 | 额外参数 |
|------|--------|--------|----------|
| 最大深度 | 后序 | int (高度) | 无 |
| 判断平衡 | 后序 | int (高度, -1表示不平衡) | 无 |
| 翻转二叉树 | 前序或后序 | *TreeNode | 无 |
| 对称二叉树 | 同时递归两棵子树 | bool | 无 |
| 路径总和 | 前序 | bool | 剩余 target |
| 所有路径 | 前序 (自顶向下) | void | 当前路径 slice |
| 直径 | 后序 | int (最长臂) | 全局变量记录最大 l+r |
| 最近公共祖先 | 后序 | *TreeNode | 无 |
| 验证 BST | 中序 或 区间递归 | bool | min/max |
| 从前/中序构建树 | 分治 | *TreeNode | 子数组范围 |

### 树 + DFS 的代码骨架

```go
func solve(root *TreeNode) ResultType {
    // base case
    if root == nil { return baseValue }
    
    // 递归左右
    left := solve(root.Left)
    right := solve(root.Right)
    
    // 利用 left, right 算当前根的结果
    result := combine(root.Val, left, right)
    
    // 可能更新全局答案
    updateGlobal(left, right)
    
    return result
}
```

**下一站**：→ [practice.md - Day 4](practice.md#day-4) → [quiz.md - Day 4](quiz.md#day-4)

---

## Day 5：回溯与图遍历

### 排列 vs 组合 vs 子集的区别

```
  输入: [1, 2, 3]
  
  排列 (顺序有关, 用 used[]):
  [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]    → 6 个
  
  组合 (顺序无关, 用 start):
  [1,2] [1,3] [2,3]    (选 2 个)  → 3 个
  
  子集 (所有子集, 用 start):
  [] [1] [2] [3] [1,2] [1,3] [2,3] [1,2,3]    → 8 个
```

**关键区别在递归的「选择范围」**：
- 排列：从 0 开始，用 `used[]` 跳过已选
- 组合/子集：从 `start` 开始，保证不回头

### 去重技巧（含重复元素时）

```go
// 排列去重: 先排序，相同元素只在第一个未被使用时选
sort.Ints(nums)
if i > 0 && nums[i] == nums[i-1] && !used[i-1] { continue }

// 组合去重: 先排序，同层相同元素跳过
if i > start && nums[i] == nums[i-1] { continue }
```

### 图上 DFS vs BFS 选择

| 目标 | 选择 | 原因 |
|------|------|------|
| 遍历所有连通块 | DFS 或 BFS | 都行 |
| 最短路径（无权） | **BFS** | BFS 第一次到达即最短 |
| 所有路径 | **DFS + 回溯** | 需要枚举 |
| 判环（有向图） | DFS（三色） 或 拓扑 | 三色标记自然 |
| 拓扑排序 | BFS (Kahn) 或 DFS 后序 | 都行 |
| 连通分量数 | DFS/BFS 数块 或 并查集 | 并查集可动态加边 |

**下一站**：→ [practice.md - Day 5](practice.md#day-5) → [quiz.md - Day 5](quiz.md#day-5)

---

## Day 6：DP 状态与优化

### DP 状态设计的三种思路

#### 思路一：以「结尾位置」定义

`dp[i]` = 以 `nums[i]` 结尾的最优解。用于 LIS、最大子数组和等。

#### 思路二：以「前 i 个」定义

`dp[i]` = 前 i 个元素的最优解。用于打家劫舍、爬楼梯等。

#### 思路三：以「两个维度」定义

`dp[i][j]` = 第一串前 i 个 + 第二串前 j 个的最优解（LCS、编辑距离）。
或 `dp[i][j]` = 前 i 个物品 + 容量 j 的最优解（背包）。

### DP 和回溯的关系

```
  回溯（暴力枚举）
       ↓  发现重叠子问题
  记忆化搜索（自顶向下 DP）
       ↓  改写为循环
  递推 DP（自底向上）
       ↓  只依赖前几行/项
  空间优化（滚动数组）
```

**学习建议**：不确定 DP 怎么写时，先写回溯/递归，然后加 memo，最后改成递推。

### 常见 DP 类型速查

| 类型 | 状态定义 | 经典题 |
|------|----------|--------|
| 线性（前 i 个） | `dp[i]` | 爬楼梯、打家劫舍 |
| 线性（以 i 结尾） | `dp[i]` | LIS、最大子数组和 |
| 双序列 | `dp[i][j]` | LCS、编辑距离 |
| 01 背包 | `dp[j]` 逆序 | 分割等和子集 |
| 完全背包 | `dp[j]` 正序 | 零钱兑换 |
| 区间 DP | `dp[i][j]` = 区间 [i,j] | 戳气球、最长回文子串 |
| 状态压缩 | `dp[mask]` | 旅行商（面试少见） |

**下一站**：→ [practice.md - Day 6](practice.md#day-6) → [quiz.md - Day 6](quiz.md#day-6)

---

## Day 7：综合与查漏补缺

### 综合题的拆解方法

真实面试题往往是多个模式的组合。拆解步骤：

1. **识别输入结构**：图？树？数组？
2. **识别问题类型**：求最值？遍历？判断？计数？
3. **拆成子问题**：每个子问题用什么模式？
4. **组装**：子问题之间的关系（先后/嵌套）

### 常见组合

| 组合 | 例题 |
|------|------|
| 图 + BFS | 单词接龙（最短变换） |
| 图 + 拓扑 | 课程表 |
| 图 + 并查集 | 省份数量、账户合并 |
| 树 + DFS + 回溯 | 路径总和 III |
| 数组 + 哈希表 + 技巧 | 最长连续序列 |
| 链表 + 快慢 + 反转 | 回文链表 |
| 滑窗 + 哈希 | 最小覆盖子串 |
| DP + 贪心 | 跳跃游戏 |

### 查漏清单

回顾这 7 天，每个类型至少要能独立写出 1 道：

- [ ] 双指针/滑窗
- [ ] 链表反转/合并
- [ ] 栈匹配/单调栈
- [ ] 堆 TopK
- [ ] BFS 最短路径
- [ ] 树递归（前/中/后序）
- [ ] 回溯（排列/组合/子集）
- [ ] 一维 DP
- [ ] 二维 DP / 背包
- [ ] 并查集
- [ ] 拓扑排序

**下一站**：→ [practice.md - Day 7](practice.md#day-7) → [quiz.md - Day 7](quiz.md#day-7)。完成即完成 7 日速通。
