# 组合与刷题技巧 — 按日分节

> 每日读完 algorithm.md 当日小节后，再读本文件同日小节。读完后做 **practice.md** 当日例题，再做 **quiz.md** 当日自测。

> **你现在在：选型层（When/Why）**
> - 看什么：题面信号、套路组合、决策路径、易错分流  
> - 暂时不看：完整代码实现与细节推导  
> - 下一站：`practice.md` / `quiz.md`（实战层）

---

## 模式信号速查表（贯穿 7 天，做题前扫一眼）

> 遇到一道题，先扫左列找到匹配的信号，右列就是你的第一直觉。详细决策树见 [thinking.md](thinking.md)。

| 题面信号 | → 数据结构 | → 算法模式 | 典型题 |
|----------|-----------|-----------|--------|
| 有序数组 + 目标值 | 数组 | 二分 / 相向双指针 | LC167, LC33 |
| 连续子数组/子串 + 最长/最短 | 数组 + map/计数 | 滑动窗口 | LC3, LC76, LC209 |
| 所有排列/组合/子集 | 数组 | 回溯 | LC46, LC78, LC39 |
| 下一个更大/更小 | 栈 | 单调栈 | LC496, LC739 |
| 合并 K 个有序 / TopK | 堆 | 多路归并 / 堆维护 | LC23, LC215 |
| 树的深度/路径/属性 | 树 | DFS 递归（前/中/后序） | LC104, LC112, LC236 |
| 按层输出 / 最短步数 | 队列 | BFS | LC102, LC127 |
| 是否能 / 方案数 / 最值 + 子序列 | 数组 | DP | LC70, LC300, LC322 |
| 连通/分组/朋友圈 | 并查集 或 图 | Union-Find / DFS | LC547, LC200 |
| 依赖/先修/执行顺序 | 图 | 拓扑排序 | LC207, LC210 |
| 括号/嵌套/匹配 | 栈 | 栈匹配 | LC20, LC32 |
| 原地/O(1) 空间 | 数组 | 双指针 / 位运算 | LC26, LC283 |

---

## 通用刷题技巧（贯穿 7 天）

1. **UMPIRE 先行**：每道题都走一遍 Understand → Match → Plan → Implement → Review → Evaluate（详见 [thinking.md](thinking.md)）。
2. **先想再写**：口头说清「用什么结构、什么循环、边界」，再写代码，减少返工。
3. **写完必检查**：过一遍 [边界清单](thinking.md)（空、单元素、全同、溢出、奇偶）。
4. **Golang 注意**：slice 传参是引用、map 取不到 key 返回零值、递归尽量用返回值而非全局变量、收集 path 时深拷贝。
5. **时间**：自测题限时（20～30 分钟/题），模拟笔试节奏。

---

## 先明确边界：algorithm vs combo

| 文件 | 核心回答的问题 | 内容形态 | 不包含什么 |
|------|----------------|----------|------------|
| `algorithm.md` | **怎么做**（实现） | 模板、推导、复杂度、代码、逐步示例 | 大量“题面识别/选型决策” |
| `combo.md` | **什么时候用**（选型） | 触发信号、套路组合、决策路径、易错分流 | 重复粘贴完整算法代码 |

一句话记忆：
- `algorithm.md` = **战术动作库**（把动作练熟）
- `combo.md` = **战场决策图**（先决定用哪个动作）

---

## Day 1：数组 + 双指针与滑窗

Day 1 不是一个技巧，而是一组“数组题入口组合”。下面 8 个是高频起手式。

### Day 1：8 个高频组合套路

| 触发信号 | 组合套路 | 为什么是它 | 代表题 |
|------|------|------|------|
| 无序数组 + 两数配对 | 哈希表 + 一次遍历 | 一边查补数一边记录，O(n) | LC1 |
| 有序数组 + 目标和 | 相向双指针 | 单调性支持左右收缩 | LC167 |
| 三数目标和 | 排序 + 固定一位 + 相向双指针 | 降维到“两数和” | LC15 |
| 原地删除/去重 + O(1) 空间 | 读写双指针（同向） | 读指针扫描，写指针落位 | LC26, LC27, LC283 |
| 连续区间 + 最长/最短 | 可变滑窗 + 哈希计数 | 右扩左缩维护合法窗口 | LC3, LC76, LC209 |
| 定长区间最值/平均值 | 固定滑窗 + 滚动和 | 每步 O(1) 更新窗口值 | LC643 |
| 有序边界（首个/末个满足） | 二分 + 左右边界模板 | 两次二分定位区间 | LC34, LC35 |
| “最小可行值/最大可行值” | 答案二分 + `check(mid)` | 二分答案空间而非下标 | LC875, LC1011 |

### 如何选择双指针模式

```
  题目要求            →  选哪种双指针
  ─────────────────────────────────────
  有序数组两数之和     →  相向双指针
  判断回文串           →  相向双指针
  原地去重/移动元素    →  同向双指针（读写指针）
  连续子串/子数组优化  →  滑动窗口（同向变体）
```

### Day 1 选型决策树（面试 30 秒版）

```
有序吗？
├─ 是
│  ├─ 找和/配对      → 相向双指针
│  └─ 找边界/位置    → 二分边界
└─ 否
   ├─ 连续子数组/子串？
   │  ├─ 求和个数     → 前缀和 + 哈希
   │  ├─ 最长/最短    → 滑动窗口
   │  └─ 固定长度     → 固定窗口
   ├─ 原地修改 + O(1) → 读写双指针
   └─ 最小化最大值类  → 答案二分 + check
```

### 滑动窗口四连问（做题前先回答）

1. **窗口维护什么状态？** `count` / `sum` / `need, have`
2. **右指针何时移动？** 一般每轮都 `r++`
3. **左指针何时收缩？** 窗口不合法，或在求最短时窗口已满足
4. **答案何时更新？** 在窗口合法时更新（最长/最短逻辑不同）

### 四种窗口变体速查

| 问题 | 窗口状态 | 何时收缩 | 更新答案 |
|------|----------|----------|----------|
| 最长无重复子串 | `count[char]` | `count[c] > 1` | 收缩后 `r-l+1` |
| 最小覆盖子串 | `need/have` | 满足覆盖后尽量收缩 | 收缩时更新最小长度 |
| 长度最小的子数组 | `sum` | `sum >= target` | 收缩时更新最小长度 |
| 固定长度最大和 | `sum` | 窗口超过 `k` | 每步更新 `max` |

### Day 1 组合技巧小抄

- **排序 + 双指针**：把 `O(n^2)` 暴力降到 `O(n)`（外层固定一个数时总 `O(n^2)`）
- **哈希 + 滑窗**：状态可增可减，适合“连续区间”题
- **前缀和 + 哈希**：连续区间“和/个数”题优先试这个（如 `pre[r]-pre[l]=k`）
- **二分边界**：想清楚找的是“第一个满足”还是“最后一个满足”
- **答案二分**：先写 `check(mid)`，再二分最小可行值

### 边界提醒

- **空数组**：入口先判 `len(nums) == 0`
- **全相同元素**：去重后可能只剩 1 个
- **全不满足/全满足**：如 `target` 极小或极大
- **窗口初始长度**：固定窗口先判 `len(nums) < k`

**下一站**：→ [practice.md - Day 1](practice.md#day-1) → [quiz.md - Day 1](quiz.md#day-1)

---

## Day 2：链表 + 快慢指针与 dummy

本日只关注**链表题怎么选策略**（dummy/快慢/反转拼接），具体代码实现看 `algorithm.md` Day 2。

### dummy 节点判断法

**用不用 dummy？** 问自己一个问题：**头节点可能变吗？**
- 删除操作可能删掉 head → **用**
- 合并两链表，新头不确定 → **用**
- 反转链表，head 变成尾 → 可用可不用（三指针法不需要）
- 只是遍历/查找 → 不用

### 链表题的常见组合

| 问题 | 技巧组合 |
|------|----------|
| 反转整个链表 | 三指针迭代 或 递归 |
| 反转前 k 个 / 区间反转 | 定位到区间 + 反转 + 接回 |
| 删除倒数第 k 个 | 快指针先走 k 步 + dummy |
| 合并两个有序 | dummy + 比较 |
| 合并 K 个有序 | 堆 + dummy（Day 3 堆） |
| 判环 / 找环入口 | 快慢指针 |
| 找中点 | 快慢指针 |
| 排序链表 | 找中点 + 归并排序 |
| 回文链表 | 找中点 + 反转后半 + 比较 |

### 链表调试技巧

- **画图**：每一步都画出节点和箭头，标清 prev/cur/next 指向
- **特别注意**：`cur.Next = prev` 之后原来的 `cur.Next` 就丢了，所以要提前 `next = cur.Next`
- **测试**：nil 链表、单节点、两节点、奇/偶长度

**下一站**：→ [practice.md - Day 2](practice.md#day-2) → [quiz.md - Day 2](quiz.md#day-2)

---

## Day 3：栈 + 队列 + 堆的选用

本日只关注**容器选型与场景分流**（栈/队列/堆/双端队列），不重复算法模板代码。

### 什么时候用什么

```
  需要「最近的」匹配 / 嵌套结构    →  栈
  需要「单调性」/ 下一个更大更小   →  单调栈
  需要「按层扩展」/ 最短步数       →  队列 (BFS)
  需要「动态取最值」/ TopK         →  堆
  需要「窗口内最值」               →  单调双端队列
```

### 单调栈要点

- **栈内存下标**（不是值），因为经常需要下标计算距离
- **严格单调**还是**非严格单调**？看题是「更大」还是「大于等于」
- **正向还是反向遍历**？取决于求「右边的」还是「左边的」

### 堆题选型口诀

- **TopK / 实时维护前 K 大（小）** → 固定大小堆  
- **合并 K 路有序流** → 堆里放每一路当前头  
- **动态最值（不断有新元素）** → 堆优先于每次全量排序  

### BFS 选型提醒（不展开实现）

- **是否关心“第几步/第几层”**：关心则分层，不关心则普通队列遍历  
- **visited 何时标记**：入队时标记（不是出队时）  
- 具体模板统一见 `algorithm.md` Day 3

**下一站**：→ [practice.md - Day 3](practice.md#day-3) → [quiz.md - Day 3](quiz.md#day-3)

---

## Day 4：树题模板

本日只关注**树题决策顺序**：先定遍历序，再定递归返回值，再补额外参数。

### 解树题的三问

拿到一道树的题，先问自己：

1. **用什么序？** 需要先处理根 → 前序；需要左右结果才能算根 → 后序；BST 有序 → 中序
2. **递归函数返回什么？** 高度、bool、节点指针、最大值……
3. **需要传什么额外信息？** min/max 区间、当前路径、父节点……

### 常见树题模式

| 问题 | 遍历序 | 返回值 | 额外参数 |
|------|--------|--------|----------|
| 最大深度 | 后序 | int (高度) | 无 |
| 判断平衡 | 后序 | int (高度, -1表示不平衡) | 无 |
| 翻转二叉树 | 前序或后序 | *TreeNode | 无 |
| 对称二叉树 | 同时递归两棵子树 | bool | 无 |
| 路径总和 | 前序 | bool | 剩余 target |
| 所有路径 | 前序 (自顶向下) | void | 当前路径 slice |
| 直径 | 后序 | int (最长臂) | 全局变量记录最大 l+r |
| 最近公共祖先 | 后序 | *TreeNode | 无 |
| 验证 BST | 中序 或 区间递归 | bool | min/max |
| 从前/中序构建树 | 分治 | *TreeNode | 子数组范围 |

### 树题决策顺序（不展开实现）

1. 先定遍历序（前/中/后/层序）  
2. 再定返回值（高度/bool/节点指针）  
3. 最后补参数（区间、路径、父节点）  

> 代码模板统一看 `algorithm.md` Day 4。

**下一站**：→ [practice.md - Day 4](practice.md#day-4) → [quiz.md - Day 4](quiz.md#day-4)

---

## Day 5：回溯与图遍历

本日只关注**回溯分支设计与图遍历选型**，不重复 DFS/BFS/回溯模板实现。

### 排列 vs 组合 vs 子集的区别

```
  输入: [1, 2, 3]
  
  排列 (顺序有关, 用 used[]):
  [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]    → 6 个
  
  组合 (顺序无关, 用 start):
  [1,2] [1,3] [2,3]    (选 2 个)  → 3 个
  
  子集 (所有子集, 用 start):
  [] [1] [2] [3] [1,2] [1,3] [2,3] [1,2,3]    → 8 个
```

**关键区别在递归的「选择范围」**：
- 排列：从 0 开始，用 `used[]` 跳过已选
- 组合/子集：从 `start` 开始，保证不回头

### 去重技巧（不展开实现）

- **排列去重**：排序后，`相同元素 + 前一个未被使用` 时跳过  
- **组合去重**：排序后，同层相同元素跳过（`i > start && nums[i] == nums[i-1]`）  
- 具体代码模板见 `algorithm.md` Day 5。

### 图上 DFS vs BFS 选择

| 目标 | 选择 | 原因 |
|------|------|------|
| 遍历所有连通块 | DFS 或 BFS | 都行 |
| 最短路径（无权） | **BFS** | BFS 第一次到达即最短 |
| 所有路径 | **DFS + 回溯** | 需要枚举 |
| 判环（有向图） | DFS（三色） 或 拓扑 | 三色标记自然 |
| 拓扑排序 | BFS (Kahn) 或 DFS 后序 | 都行 |
| 连通分量数 | DFS/BFS 数块 或 并查集 | 并查集可动态加边 |

**下一站**：→ [practice.md - Day 5](practice.md#day-5) → [quiz.md - Day 5](quiz.md#day-5)

---

## Day 6：DP 状态与优化

本日只关注**状态定义范式与优化路线**，状态转移代码细节看 `algorithm.md` Day 6。

### DP 状态设计的三种思路

#### 思路一：以「结尾位置」定义

`dp[i]` = 以 `nums[i]` 结尾的最优解。用于 LIS、最大子数组和等。

#### 思路二：以「前 i 个」定义

`dp[i]` = 前 i 个元素的最优解。用于打家劫舍、爬楼梯等。

#### 思路三：以「两个维度」定义

`dp[i][j]` = 第一串前 i 个 + 第二串前 j 个的最优解（LCS、编辑距离）。
或 `dp[i][j]` = 前 i 个物品 + 容量 j 的最优解（背包）。

### DP 和回溯的关系

```
  回溯（暴力枚举）
       ↓  发现重叠子问题
  记忆化搜索（自顶向下 DP）
       ↓  改写为循环
  递推 DP（自底向上）
       ↓  只依赖前几行/项
  空间优化（滚动数组）
```

**学习建议**：不确定 DP 怎么写时，先写回溯/递归，然后加 memo，最后改成递推。

### 常见 DP 类型速查

| 类型 | 状态定义 | 经典题 |
|------|----------|--------|
| 线性（前 i 个） | `dp[i]` | 爬楼梯、打家劫舍 |
| 线性（以 i 结尾） | `dp[i]` | LIS、最大子数组和 |
| 双序列 | `dp[i][j]` | LCS、编辑距离 |
| 01 背包 | `dp[j]` 逆序 | 分割等和子集 |
| 完全背包 | `dp[j]` 正序 | 零钱兑换 |
| 区间 DP | `dp[i][j]` = 区间 [i,j] | 戳气球、最长回文子串 |
| 状态压缩 | `dp[mask]` | 旅行商（面试少见） |

**下一站**：→ [practice.md - Day 6](practice.md#day-6) → [quiz.md - Day 6](quiz.md#day-6)

---

## Day 7：综合与查漏补缺

本日只关注**综合题拆解与模式组装**：识别输入结构 → 拆子问题 → 组合解法。

### 综合题的拆解方法

真实面试题往往是多个模式的组合。拆解步骤：

1. **识别输入结构**：图？树？数组？
2. **识别问题类型**：求最值？遍历？判断？计数？
3. **拆成子问题**：每个子问题用什么模式？
4. **组装**：子问题之间的关系（先后/嵌套）

### 常见组合

| 组合 | 例题 |
|------|------|
| 图 + BFS | 单词接龙（最短变换） |
| 图 + 拓扑 | 课程表 |
| 图 + 并查集 | 省份数量、账户合并 |
| 树 + DFS + 回溯 | 路径总和 III |
| 数组 + 哈希表 + 技巧 | 最长连续序列 |
| 链表 + 快慢 + 反转 | 回文链表 |
| 滑窗 + 哈希 | 最小覆盖子串 |
| DP + 贪心 | 跳跃游戏 |

### 查漏清单

回顾这 7 天，每个类型至少要能独立写出 1 道：

- [ ] 双指针/滑窗
- [ ] 链表反转/合并
- [ ] 栈匹配/单调栈
- [ ] 堆 TopK
- [ ] BFS 最短路径
- [ ] 树递归（前/中/后序）
- [ ] 回溯（排列/组合/子集）
- [ ] 一维 DP
- [ ] 二维 DP / 背包
- [ ] 并查集
- [ ] 拓扑排序

**下一站**：→ [practice.md - Day 7](practice.md#day-7) → [quiz.md - Day 7](quiz.md#day-7)。完成即完成 7 日速通。
