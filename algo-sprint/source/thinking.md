# 解题思维框架 — 你的「操作系统」

> **这是整个 7 日速通最重要的一份文件。** 它不教具体算法，而是教你面对一道从未见过的题时，大脑应该跑什么「程序」。建议 Day 1 之前通读一遍，之后每天做题前快速扫一眼「模式识别表」和「边界清单」。

---

## 一、UMPIRE 解题六步法

面试/笔试时，**不要拿到题就写代码**。按这六步走，慢就是快。

### U — Understand（理解）

- 用自己的话复述题意，确认：输入是什么？输出是什么？约束条件（n 的范围、是否有序、是否有重复）？
- 走一个小例子，手工模拟期望的输出。
- 问自己：有没有隐含条件（如「保证有解」「结果唯一」）？

### M — Match（匹配模式）

- 这道题像我见过的哪类题？（参考下面的「模式识别决策树」）
- 识别出 1～2 个候选模式，快速评估是否可行。

### P — Plan（规划）

- 选定模式后，口头/纸上描述：
  - 用什么数据结构？
  - 主循环/递归的结构是什么？
  - 状态变量有哪些？
  - 时间/空间复杂度预估。
- **在写代码之前**，先确认计划能 cover 所有 case。

### I — Implement（实现）

- 按照计划翻译成代码。
- 写的时候保持代码整洁：有意义的变量名、适当空行。
- 遇到不确定的边界先留 `// TODO` 标记，不要卡住。

### R — Review（检查）

- 写完后，用一个简单例子 **手动走一遍代码**（dry run），检查逻辑。
- 逐条过「边界清单」（见下方），确认每种特殊情况都被处理。

### E — Evaluate（评估）

- 最终确认时间/空间复杂度，说出来。
- 想一下：有没有更优解？如果有但时间不够，先提一句思路。

---

## 二、模式识别决策树

> 拿到一道题，按下面的「题面线索」快速定位到候选模式。

### 第一步：看输入结构

```
输入是什么？
├── 数组/字符串
│   ├── 有序？ → 二分查找 / 相向双指针
│   ├── 求子数组/子串？ → 滑动窗口 / 前缀和
│   ├── 求排列/组合/子集？ → 回溯
│   └── 求最值/方案数？ → 动态规划（或贪心）
├── 链表 → 快慢指针 / dummy / 递归
├── 树
│   ├── 求路径/深度/属性？ → DFS 递归（前/中/后序）
│   ├── 按层？ → BFS 层序
│   └── BST 相关？ → 中序 / 区间递归
├── 图
│   ├── 最短路径（无权）？ → BFS
│   ├── 遍历/连通？ → DFS / BFS / 并查集
│   └── 依赖/顺序？ → 拓扑排序
└── 其他（数学/设计/模拟） → 按题意分析
```

### 第二步：看关键词

| 题面中的关键词/信号 | 优先考虑的模式 |
|---------------------|----------------|
| 「两数之和」「配对」 | 哈希表 / 双指针 |
| 「有序」「排序后」「第 K 个」 | 二分查找 / 堆 |
| 「连续子数组」「子串」「窗口」 | 滑动窗口 |
| 「最长/最短」+「子序列」 | DP |
| 「最长/最短」+「子数组/子串」 | 滑窗 或 DP |
| 「所有可能」「所有排列/组合」 | 回溯 |
| 「最少步数」「最短距离」 | BFS |
| 「是否能」「方案数」 | DP 或 回溯+剪枝 |
| 「连通」「分组」「朋友圈」 | 并查集 / DFS |
| 「依赖关系」「先修课」 | 拓扑排序 |
| 「下一个更大/更小」 | 单调栈 |
| 「括号匹配」「嵌套」 | 栈 |
| 「合并 K 个有序」 | 堆（多路归并） |
| 「原地操作」「O(1) 空间」 | 双指针 / 位运算 |
| 「树/图的路径」 | DFS + 回溯 |

### 第三步：验证

选定模式后，快速问自己三个问题：
1. 这个模式的时间复杂度是否在 n 的范围内可接受？（n≤10⁵ 大约需要 O(n log n) 或更优）
2. 我能定义清楚「状态」（DP）或「选择」（回溯）吗？
3. 有没有反例推翻这个模式？

---

## 三、「我卡住了」逃生路线

做题超过 10 分钟还没思路时，按这个顺序尝试：

1. **换个小例子**：用最简单的输入（n=1, 2, 3）手动算，找规律。
2. **暴力先行**：先写 O(n²) 或 O(2^n) 的暴力解，理解结构后再优化。
3. **反向思考**：从结果倒推——如果我已经知道答案，它有什么性质？
4. **拆子问题**：这个大问题能拆成几个独立的小问题吗？（分治/DP 信号）
5. **加约束**：如果输入是有序的呢？如果只有两种值呢？简化问题后找到思路再放开。
6. **画图**：链表画箭头、树画层、图画节点连线——视觉化经常能发现规律。

---

## 四、边界清单（做完题必检查）

每道题写完后，逐条过一遍：

- [ ] **空输入**：数组长度 0、链表 nil、树 nil、字符串 ""
- [ ] **单元素**：数组只有 1 个、链表只有 1 个节点、树只有根
- [ ] **全同值**：`[1,1,1,1]`、所有节点 val 相同
- [ ] **有序极端**：已经完全有序 / 完全逆序
- [ ] **最大最小值**：int 溢出（两数相加可能超 int32）、负数
- [ ] **重复元素**：去重逻辑是否正确
- [ ] **奇偶**：长度奇偶对快慢指针、中点的影响
- [ ] **环 / 自环**：链表有环、图有自环或重边

---

## 五、Golang 刷题常踩的坑

| 坑 | 说明 | 避免方式 |
|----|------|----------|
| slice 是引用 | `path = append(path, x)` 后传给结果集，后续修改 path 会影响已存结果 | 收集结果时用 `append([]int(nil), path...)` 深拷贝 |
| map 遍历无序 | `for k := range m` 每次顺序不同 | 需要顺序时先取 keys 排序 |
| 整数溢出 | `nums[i]+nums[j]` 可能超 int32 | 用 int（Go 中 64 位）或显式 int64 |
| 递归栈深 | 10⁵ 深度可能爆栈 | 改迭代或增大栈（面试时口头说明即可） |
| `container/heap` 接口 | Push/Pop 参数是 `interface{}`，需类型断言 | 定义类型后实现 5 个方法，调用 `heap.Push`/`heap.Pop` |
| 字符串不可变 | `s[i] = 'a'` 编译错误 | 转 `[]byte` 或 `[]rune` 再操作 |

---

## 六、面试时间管理（45 分钟一道）

| 阶段 | 时间 | 做什么 |
|------|------|--------|
| Understand | 3 min | 读题、复述、确认边界 |
| Match + Plan | 5 min | 识别模式、口述方案、估复杂度 |
| Implement | 15 min | 写代码 |
| Review | 5 min | dry run + 边界清单 |
| 优化/讨论 | 剩余 | 更优解思路、follow-up |

> 笔试（多题限总时）时，先扫所有题估难度，从最有把握的开始，每题不超 30 分钟。

---

## 七、每日复盘模板

每天做完 quiz.md 后，花 5 分钟填这个：

```
## Day X 复盘

### 今天掌握了什么模式？
-

### 哪道题卡住了？卡在哪一步？（U/M/P/I/R/E 中的哪步）
-

### 漏掉了什么边界？
-

### 明天要重点回顾什么？
-
```

建议在 algo-sprint 目录下建一个 `review.md`，每天追加。这是你**最有价值的复习材料**。
